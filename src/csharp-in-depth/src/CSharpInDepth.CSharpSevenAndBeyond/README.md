# [C# 7 and beyond](../../README.md)

1. [Composition using tuples](#composition-using-tuples)
2. [Deconstruction and pattern matching](#deconstruction-and-pattern-matching)
3. [Improving efficiency with more pass by reference](#improving-efficiency-with-more-pass-by-reference)
4. [Concise code in C# 7](#concise-code-in-c-7)
5. [C# 8 and beyond](#c-8-and-beyond)

## Composition using tuples

### Introduction to tuples

___Tuples___ allow to create a single composite value from multiple individual values. They are shorthand for
composition with no extra encapsulation where values are related to each other.

```csharp
static (int min, int max) MinMax(IEnumerable<int> source) { 
    ... 
    return (min, max);
}
...
int[] values = { 2, 7, 3, -5, 1, 0, 10 };
var extremes = MinMax(values);
Console.WriteLine(extremes.min);
Console.WriteLine(extremes.max);
// Inferred element names for tuple literals
from emp in employees
join dept in departments on emp.DepartmentId equals dept.Id
select (emp.Name, emp.Title, DepartmentName: dept.Name);
// Accessing elements by name and position
var tuple = (x: 5, 10);
Console.WriteLine(tuple.x); // 5
Console.WriteLine(tuple.Item1); // 5
Console.WriteLine(tuple.Item2); // 10
```

### Tuple type conversions

__Implicit conversions__

```csharp
(byte, object) tuple = (5, "text"); // ok
(byte, object) tuple = (300, "text"); // error CS0029: Canno implicitly convert type 'int' to 'byte'.
```

__Explicit conversions__

```csharp
int x = 300;
var tuple = ((byte, string)) (x, "text"); // ok
var tuple = ((byte) x, "text"); // ok

// Invalid name mismatch
(int a, int b, int c, int, int) tuple = 
    (a: 10, wrong: 20, 30, pointless: 40, 50);
```

__Conversions between tuple types__

```csharp
var t1 = (300, "text");
(long, string) t2 = t1; // valid implicit
(byte, string) t3 = t1; // invalid: no implicit convertion from int to byte
(byte, string) t4 = ((byte, string)) t1; // valid explicit
(object, object) t5 = t1; // valid implicit
(string, string) t6 = ((string, string)) t1; // invalid explicit: no convertion from int to string


var source = (a: 10, wrong: 20, 30, pointless: 40, 50);
(int a, int b, int c, int, int) tuple = source; // valid implicit convertion because of type-to-type conversion
```

__Element name checking in inheritance__

```csharp
interface ISample {
    void Method((int x, string) tuple);
}
// Invalid: worng type elements
public void Method((string x, object) tuple { ... }
// Invalid: first element is missing a name
public void Method((int x, string) tuple { ... } 
// Invalid: second element has a name
public void Method((int x, string extra) tuple { ... } 
// Invalid: first element has wrong name
public void Method((int wrong, string) tuple { ... } 
// Invalid: wrong tuple type arity
public void Method((int x, string, int) tuple { ... }
// Valid!
public void Method((int x, string) tuple { ... } 
```

__Equality and inequality operators__

```csharp
var t1 = (x: "x", y: "y", z: 1);
var t2 = ("x", "y", 1);
t1 == t2 // true
/*
Code generated by compiler
t1.Item1 == t2.Item1 &&
t1.Item2 == t2.Item2 &&
t1.Item3 == t2.Item3;
*/
t1 != t2 // false
/*
Code generated by compiler
t1.Item1 != t2.Item1 &&
t1.Item2 != t2.Item2 &&
t1.Item3 != t2.Item3;
*/
```

[Back to top ⇧](#c-7-and-beyond)

## Deconstruction and pattern matching

### Deconstructing tuples into multiple variables

```csharp
var tuple = (10, "text");
// Deconstruct tuple to new variables a, b implicitly
var (a, b) = tuple;
// Deconstruct tuple to new variables c, d explicitly
(int c, string d) = tuple;
// Deconstruct tuple to existing variables
int e;
string f;
(e, f) = tuple;
// Using discards
var tuple = (1, 2, 3, 4);
var (x, y, _, _) = tuple;
Console.WriteLine(_); // the name '_' does ot exist in the current context
```

### Deconstructing nontuple types

__Instance deconstruction methods__
Rules:

- the method should be accessible to the code doing the deconstruction.
- it must be a _void_ method
- there must be at least two parameters
- it must be nongeneric

```csharp
internal class Point {
    public double X {get; set;}
    public double Y {get; set;}
    ...
    public void Deconstruct(out double x, out douoble y) {
        x = X;
        y = Y;
    }
}

// Usage
var point = new Point(1.5, 20);
var (x, y) = point;
```

### Pattern matching in C# 7

The basic idea of pattern matching is to test a certain aspect of a value and use the result of that test to perform
another action.

```csharp
static double Perimeter(Shape shape)
{
    switch (shape)
    {
        case null:
            throw new ArgumentNullException(nameof(shape));
        case Rectangle rect:
            return 2 * (rect.Height + rect.Width);
        case Circle circle:
            return 2 * PI * circle.Radius;
        case Triangle tri:
            return tri.SideA + tri.SideB + tri.SideC;
        default:
            throw new ArugmentException(...);
    }
}
```

### Using the three kinds of patterns introduced in C# 7

Three kinds of patterns in C# 7:

- Constant patterns
- Type patterns
- The __var__ pattern

#### Constant pattern

The pattern consists entirely of a compile-time constant expression, which is then checked for equality with input.

```csharp
static void Match(object input)
{
    if (input is "hello")
        WriteLine("Input is string hello");
    else if (input is 5L)
        WriteLine("Input is long 5");
    else if (input is 10)
        WriteLine("Input is int 10");
    else
        WriteLine("Input didn't match hello, long 5 or int 10");
}
```

#### Type patterns

A ___type pattern___ consists of a type and an identifier - a bit like a variable declaration.

```csharp
static double Perimeter(Shape shape)
{
    if (shape == null)
        throw new ArgumentNullException(nameof(shape));
    if (shape is Rectangle rect)
        return 2 * (rect.Height + rect.Width);
    if (shape is  Circle circle)
        return 2 * PI * circle.Radius;
    if (shape is  Triangle tri)
        return tri.SideA + tri.SideB + tri.SideC;
    
    throw new ArugmentException(...);
}
```

#### The ___var___ pattern

The ___var___ pattern looks like a type pattern but using ___var___ as the type, so it's just ___var___ followed by
identifier:
___someExpression is var x___
Unlike type patterns it doesn't test anything. It always matches, resulting in a new variable with the same compile-time
type as __input__, with the same value as __input__

```csharp
static double Perimeter(Shape shape)
{
    switch (shape ?? CreateRandomShape())
    {
        case Rectangle rect:
            return 2 * (rect.Height + rect.Width);
        case Circle circle:
            return 2 * PI * circle.Radius;
        case Triangle tri:
            return tri.SideA + tri.SideB + tri.SideC;
        case var actualShape:
            throw new InvaidOperationException($"Shape type {actualShape.GetType()} perimeter unknown");
    }
}
```

[Back to top ⇧](#c-7-and-beyond)

## Improving efficiency with more pass by reference

### ___Ref___ locals and ___ref___ returns

#### Ref locals

Ref local allows to declare a new local variable that shares the same data as an existing one (by reference).

```csharp
int x = 10;
ref int y = ref x;
x++;
y++;
WriteLine(x); // 12

// Modify array elements
var array = new (int x, int y)[10];
for (int i = 0; i < arrray.Length; i++) {
    array[i] = (i, i);
}
for (int i = 0; i < arrray.Length; i++) {
    // For each element of the array, increments x and doubles y
    ref var elements = ref array[i];
    element.x++;
    element.y *= 2;
}
```

Limitations:

- Ref locals have to be initialized at the point of declaration
- No ref fields, or local variables that would live beyond the method call
- No references to read-only variables
- Types: only identity conversions are permitted

#### Ref returns

Reference return values (or ref returns) are values that a method returns by reference to the caller.

```csharp
static void Main() {
    int x  = 10;
    ref int y = ref RefReturn(ref x);
    y++;
    WriteLine(x); // 11
}
static ref int RefReturn(ref int p) {
    return ref p;
}
```

A method can't return a storage location that was created on the stack, because when the stack is popped, the storage
location won't be valid anymore.

Valid cases:

- __ref__ or __out__ parameters
- Fields of reference types
- Fields of struct where the struct variable is a __ref__ or __out__ parameter
- Array elements

Invalid cases:

- Local variables declared in the method (including value parameters)
- Fields of struct variables declared in the method

#### Ref readonly

Ref readonly allows to alias a read-only field for the sake of efficiency to avoid copying and allows read-only access
via the ref variable.

```csharp
static readonly int field = DateTIme.UtcNow.Second;
static ref readonly int GetFieldAlias() => ref field;

static void Main() {
    ref readonly int local = ref GetFieldAlis();
    WriteLine(local);
}
```

### in parameters

When a parameter has the __in__ modifier, the intention is that the method won't change the parameter value, so a
variable can be passed by reference to avoid copying. The caller does not have to specify the __in__ modifier for the
argument.

```csharp
static void PrintDateTime(in DateTime value) { // method declaration with in parameter
    string text = value.ToString("yyy-MM-dd'T'HH:mm:ss", CultureInfo.InvariantCulture);
    WriteLine(text);
}
static void Main() {
    DateTime start = DateTime.UtcNow;
    PrintDateTime(start); // variable is passed by reference implicitly
    PrintDateTime(in start); // variable is passed by reference explicitly
    PrintDateTime(start.AddMinutes(1)); // Result is copied to hidden local variable, which is passed by reference
    PrintDateTime(in start.AddMinutes(1)); // Compile-time error: argument can't be passed by reference
```

### Declaring structs as readonly

You use the readonly modifier to declare that a structure type is immutable. All data members of a readonly struct must
be read-only as follows:

- Any field declaration must have the readonly modifier
- Any property, including auto-implemented ones, must be read-only. In C# 9.0 and later, a property may have an init
  accessor.

```csharp
public readonly struct YearMonthDay {
    public int Year {get;}
    public int Month {get;}
    public int Day {get;}
    
    public YearMonthDay(int year, int month, int day) => (Year, Month, Day) = (year, month, day);
}
```

### Extension methods with __ref__ or __in__ parameters

```csharp
public readonly struct Vector3D
{
    public double X {get;}
    public double Y {get;}
    public double Z {get;}
    public Vector3D(double x, double y, double z) => (X, Y, Z) = (x, y, z)
}

public static double Magnitude(this in Vector3D vec) =>
    Math.Sqrt(vec.X * vec.X + vec.Y * vec.Y + vec.Z * vec.Z);
public static void OffsetBy(this ref Vector3D orig, in Vector3D off) =>
    orig = new Vector3D(orig.X + off.X, orig.Y + off.Y, orig.Z + off.Z);

var vector = new Vector3D(1.5, 2.0, 3.0);
var offset = new Vector3D(5.0, 2.5, -1.0);

vector.OffsetBy(offset);
WriteLine($"({vector.X}, {vector.Y}, {vector.Z})");
WriteLine(vector.Magnitude());
/*
    Output:
    (6.5, 4.5, 2)
    8.15475321515004
*/

ref readonly var alias = ref vector;
alias.OffsetBy(offset); // Error: trying to use a read-only variable as ref
```

### Ref-like structs

A ref-like struct value must sty on the stack, always.

```csharp
public ref struct RefLikeStruct { ... }
```

Things, that can't be done with ref-like structs:

- Can't include as a field of any type that isn't also a ref-like struct
- Can't be boxed
- Can't use as a type argument for any generic method or type, including as a type argument for a generic ref0like
  struct type.
- Can't use as the operand for the ___typeof___ operator
- Local variables can't be used anywhere the compiler might need to capture them on the heap in a special generated type
    - async methods - variable can be declared and used between await expressions, so long as it was never used cross an
      await expressions (with declaration before the await and usage after it)
    - iterator blocks - same rules as for async
    - any local variable captured by a local method, LINQ query expression, anonymous method or lambda expression

#### Span<T> and stackalloc

___Span<T>___ s a ref-like struct that provides read/write, indexed access to a section of memory ust like an array but
without any concept of owning that memory. A span is always created from something else.

```csharp
static string Generate(string alphabet, Random random, int length) {
    // Heap allocation
    char[] chars = new char[length];
    // Alternative without heap allocation
    Span<char> chars = stackallock char[length];
    for (int i = 0; i < length; i++)
    {
    chars[i] = alphabet[random.Next(alphabet.Length)];
    }
    return new string(chars);
}

string alphabet = "abcdefghijklmnopqrstuvwxyz";
Random random = new Random();
Console.WriteLine(Generate(alphabet, random, 10));
```

[Back to top ⇧](#c-7-and-beyond)

## Concise code in C# 7

### Local methods

```csharp
static void Main() {
    int x = 10;
    PrintAndIncrementX();
    PrintAndIncrementX();
    WriteLine($"After calls, x = {x}");
    
    void PrintAndIncrementX() {
        WriteLine($"x = {x}");
        x++;
    }
}
```

Local method restrictions:

- can't have any access modifiers
- can't have the ___extern___, ___virtual___, ___new___, ___override___, ___static___, or ___abstract___ modifiers
- cant' have any attributes applied to it
- can't have the same name as another local method within the same parent; there's no way to overload local methods

#### Variable access within local methods

- A local method can capture nly variables that are in scope
- A local method must be declared after the declaration of any variables it captures
- A local method can't capture ref parameters of the enclosing method
- Local methods interact with definite assignment
    - If a method that reads a captured variable is called before it's definitely assigned, that causes a compile-time
      error
    - If a local method writes to a captured variable in all possible execution flows, the variable will be definitely
      assigned at the end of any call to that method
- Local methods can't assign read-only fields

### Out variables

Inline variable declarations for out parameters: allows new variables to be declared within the method invocation
itself.

```csharp
int value;
// Before
int.TryParse(text, out value);
// After
int.TryParse(text, out int value);
```

### Improvements to numeric literals

#### Binary integer literals

C# 7 extends binary literals, now they can use a prefix of __0b__ or __0B__.
This is useful when implementing a protocol with specific bit patterns for a certain values.

```csharp
byte b1 = 135;
byte b2 = 0x83;
byte b3 = 0b10000111; // new addition, and more convenient to detect which bits are set
```

#### Underscore separators

```csharp
byte b1 = 135;
byte b2 = 0x83;
byte b3 = 0b10000111;
byte b3 = 0b1000_0111;
int maxInt32 = 2_147_483_647;
decimal largeSalary = 123_456_789.12m;
ulong alternatingBytes = 0xff_00_ff_00_ff_00_ff_00;
ulong alternatingWords = 0xffff_0000_ffff_0000;
ulong alternatingDwords = 0xffffffff_00000000;
```

Restrictions:

- you can't put an underscore at the start of the literal.
- you can't put an underscore at the end of the literal (including just before the suffix).
- you can't put an underscore directly before or after the period in a floating-point literal.

### Throw expressions

___Throw expression___ can be used in a limited set of contexts:

- As the body of a lambda expression
- As the body of an expression-bodied member
- As the second operand of the ?? operator
- As the second or third operand of the conditional ?: operator (but not both in the same expression)

```csharp
// Expression-bodied method
public void UnimplementedMethod() => throw new NotImplementedException();

public void TestPredicateNeverCalledOnEmptySequence() {
    // Lambda expression
    int count = new string[0].Count(x => throw new exceptoioon("Band!"));
    Assert.AreEquel(0, count);
}

// ?? operator (in expression-bodied method)
public static T CheckNotNull<T>(T value, string paramName) where T : class
    => value ?? thorw new ArgumentNullException(paramName);

// ?: operator (in expression-bodied method)
public static Name => initialized ? data["name"] : throw new Exceptoin(" ... ");
```

### Default literals

```csharp
// Before
public async Task<string FetchValueAsync(
    string key, CancellationToken cancellationToken = default(CancellationToken)) { ... }
// After
public async Task<string FetchValueAsync(
    string key, CancellationToken cancellationToken = default) { ... }
```

### Nontrailing named arguments

If there are any unnamed arguments after a named one, the named argument has to correspond to the same parameter as it
would if it were a simple positional argument.

```csharp
// Before
clientUploadCsv(table, null, csvData, options);
// Or
TableSchema schema = null;
clientUploadCsv(table, schema, csvData, options);
// After
clientUploadCsv(table, schema: null, csvData, options);
```

### Private protected access

You have access to a private protected member only from ode that's in the same assembly and is within a subclass of the
member declaration (or is in the same type).

### Minor improvements

#### Generic type constraints

__Enum__, __delegate__ and __unmanaged__ generic constraints have been added.

```csharp
static void EnumMethod<T>() where T : struct, Enum {}
static void DelegateMethod<T> where T : Delegate {}
static void UnmanagedMethod<T> where T : unmanaged {}
```

___Unmanaged___ type is a non-nullable, non-generic value type whose fields aren't reference types, recursively (Int32,
Double, Decimal, Guid, etc).

#### Overload resolution improvements

Valid cases in C# 7.3

- Generic type arguments must meet any constraint on the type parameters
- Static methods can't be called as if they were instance methods
- Instance methods can't be called as if they were static methods

```csharp
static void Method<T>(object x) where T : struct
    => WriteLine($"{typeof(T)} is a struct");

static void Method<T>(object x) where T : class
    => WriteLine($"{typeof(T)} is a reference type");
```

#### Attributes for fields backing automatically implemented properties

```csharp
// Before:
[Demo]
private stirng name;
public string Name
{
    get { return name; }
    set { name = value; }
}

// After
[field: Demo]
public string Name {get;set;}
```

[Back to top ⇧](#c-7-and-beyond)

## C# 8 and beyond

[Back to top ⇧](#c-7-and-beyond)
