# [C# 7 and beyond](../../README.md)

1. [Composition using tuples](#composition-using-tuples)

## Composition using tuples

### Introduction to tuples

___Tuples___ allow to create a single composite value from multiple individual values. They are shorthand for
composition with no extra encapsulation where values are related to each other.

```csharp
static (int min, int max) MinMax(IEnumerable<int> source) { 
    ... 
    return (min, max);
}
...
int[] values = { 2, 7, 3, -5, 1, 0, 10 };
var extremes = MinMax(values);
Console.WriteLine(extremes.min);
Console.WriteLine(extremes.max);
// Inferred element names for tuple literals
from emp in employees
join dept in departments on emp.DepartmentId equals dept.Id
select (emp.Name, emp.Title, DepartmentName: dept.Name);
// Accessing elements by name and position
var tuple = (x: 5, 10);
Console.WriteLine(tuple.x); // 5
Console.WriteLine(tuple.Item1); // 5
Console.WriteLine(tuple.Item2); // 10
```

### Tuple type conversions

__Implicit conversions__

```csharp
(byte, object) tuple = (5, "text"); // ok
(byte, object) tuple = (300, "text"); // error CS0029: Canno implicitly convert type 'int' to 'byte'.
```

__Explicit conversions__

```csharp
int x = 300;
var tuple = ((byte, string)) (x, "text"); // ok
var tuple = ((byte) x, "text"); // ok

// Invalid name mismatch
(int a, int b, int c, int, int) tuple = 
    (a: 10, wrong: 20, 30, pointless: 40, 50);
```

__Conversions between tuple types__

```csharp
var t1 = (300, "text");
(long, string) t2 = t1; // valid implicit
(byte, string) t3 = t1; // invalid: no implicit convertion from int to byte
(byte, string) t4 = ((byte, string)) t1; // valid explicit
(object, object) t5 = t1; // valid implicit
(string, string) t6 = ((string, string)) t1; // invalid explicit: no convertion from int to string


var source = (a: 10, wrong: 20, 30, pointless: 40, 50);
(int a, int b, int c, int, int) tuple = source; // valid implicit convertion because of type-to-type conversion
```

__Element name checking in inheritance__

```csharp
interface ISample {
    void Method((int x, string) tuple);
}
// Invalid: worng type elements
public void Method((string x, object) tuple { ... }
// Invalid: first element is missing a name
public void Method((int x, string) tuple { ... } 
// Invalid: second element has a name
public void Method((int x, string extra) tuple { ... } 
// Invalid: first element has wrong name
public void Method((int wrong, string) tuple { ... } 
// Invalid: wrong tuple type arity
public void Method((int x, string, int) tuple { ... }
// Valid!
public void Method((int x, string) tuple { ... } 
```

__Equality and inequality operators__

```csharp
var t1 = (x: "x", y: "y", z: 1);
var t2 = ("x", "y", 1);
t1 == t2 // true
/*
Code generated by compiler
t1.Item1 == t2.Item1 &&
t1.Item2 == t2.Item2 &&
t1.Item3 == t2.Item3;
*/
t1 != t2 // false
/*
Code generated by compiler
t1.Item1 != t2.Item1 &&
t1.Item2 != t2.Item2 &&
t1.Item3 != t2.Item3;
*/
```

[Back to top â‡§](#c-7-and-beyond)
